\section{Overview}
\label{sec: overview}

This section describes how the overall development process for building the system shall be carried out. Having three separate plans for implementation, integration and testing wouldn't be effective, because the three phases can (and should) be greatly intertwined to maximize efficiency in the development process: thus, a single, chronological plan is delineated. 

In fact, the decision to design the system by following the microservices architecture makes it possible to split its functionalities among different units, enforcing the separation of concerns between them and allowing the developers to implement and test each of them separately and in parallel. However, this also means that the different subsystems shall be carefully integrated together after their completion, and consequently extensive integration testing shall be performed.

\section{Development Plan}
\label{sec: development}

The development shall focus on ensuring that the most impactful and business-critical components are implemented first. The functionalities that set this platform apart from the other similar available products are recommendations and optimizations, located in the RecommendationManager and OptimizationManager components respectively: due to this consideration, the highest priority and a greater amount of development and testing resources are to be devoted to these components. Indeed, their implementation involves perfecting the Artificial Intelligence algorithms and models outlined in \hyperref[subsec:components_description]{\protect\uline{Section 2.2.2}} to generate recommendations and optimizations, and therefore requires thorough analyses to guarantee the correctness of the training and fine-tuning processes for models, because these are quite resource-consuming (in terms of both time and computation power) and, consequently, they should be iterated as few times as possible.

The platform's other functionalities are offered by the remaining microservices, each responsible for a specific subset of tasks. This modular design enables taking full advantage of the modularity and parallelizability offered by the microservices architecture, allowing teams to work on them simultaneously without being tightly coupled to the progress of other components. Such an approach is particularly efficient, as every requirement is almost always mapped to only one component.
Each microservice rarely communicates with the others, only in limited cases to offer particular functionalities, such as authorization and recommendation generation, and they do so only through a standard interface that is the REST API.
For this reason, the implementation should proceed without any interruptions or dead times.

Units within the same component are to be implemented and tested following a bottom-up strategy: that is, development shall start by building the basic units, and then these shall be progressively put together to form the whole component, taking advantage of the fact that this strategy doesn't require the developers to write complex stubs. External calls from other components shall be simulated in a standard and decoupled way by invoking the corresponding REST API endpoint: as far as it concerns unit testing, only the correctness of the calls and their inputs shall be validated, also applying mutational fuzzing techniques from valid URIs with coherent parameters. 

After components are complete and working, they can be integrated together. Integration testing shall be carried out by considering the pairs of components that interact together according to the Component View in \hyperref[fig:component_diagram]{\protect\uline{Section 2.2.1}}: they shall launch the expected calls to one another's API endpoints, in order to verify that the contract of each exposed interface is correctly interpreted by them both.

System (E2E) testing shall start immediately after integration testing, in order to ensure consistency with the requirements defined in the RASD, and validation should also be assessed by stakeholders. System testing shall be split among functional testing, aimed at straightforwardly evaluating the satisfaction of the functional requirements, and performance testing, for the remaining non-functional requirements. The latter shall verify the system's capability to withstand increasingly heavy loads (Load Testing, for requirements such as availability and scalability) and to achieve graceful degradation in case of the failure of a subset of the microservices offered (Stress Testing).