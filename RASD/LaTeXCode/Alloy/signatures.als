module signatures

var abstract sig User {}

var abstract sig Party extends User {
	var receivedRecommendations: set Recommendation
} {
	// If a Party has more recommendations about another Party in the context of the same 
		// Offer, then all, except one of them, must be REJECTED
	all disj r1, r2 : receivedRecommendations | 
		(r1.recommendedParty = r2.recommendedParty and r1.contextOffer = r2.contextOffer) implies
			r1.status = REJECTED or r2.status = REJECTED
	// NOTE: this also prevents that more of such recommendations are sent to a Party 
		// that already has an UNHANDLED or ACCEPTED recommendation about that other Party 
		// for the same Offer
}

var sig Student extends Party {
	var atUniversity: one University
} {
	// Its University must never change (as we aren't modeling profile update operations)
	atUniversity' = atUniversity
}

var sig Company extends Party {
} {
	// A Company must have recommendations only in the context of its Offers
	no r : receivedRecommendations | r.contextOffer not in offeringCompany.this
}
var sig University extends Party {}

var sig Offer {
	// offeringCompany, as a relation, must be variable because new Offers will be added to
		// the set of Offers, along with their offering Companies
	var offeringCompany: one Company,
	var applicatingStudents: set Student
} {
	// However, for a specific Offer, its offeringCompany must never change
	offeringCompany' = offeringCompany
}

var sig Recommendation {
	// contextOffer and recommendedParty, as relations, must be variable because new 
		// Recommendations will be added to the set of Recoomendations, along with their 
		// Offers and Parties to be recommended
	var contextOffer: one Offer,
	var recommendedParty: one Party,
	var status: one RecommendationStatus
} {
	// However, for a specific Recommendation:
		// its contextOffer must never change
	contextOffer' = contextOffer
		// its recommendedParty must never change
	recommendedParty' = recommendedParty
		// when not UNHANDLED, its status must never change
	(not status = UNHANDLED) implies status' = status
	// NOTE: together with the facts that all new Recommendations must have been 
		//generated by using the appropriate predicate and that same predicate sets the 
		// status to UNHANDLED in the creation instant, this implies that every new
		// Recommendation starts with UNHANDLED, and thus it is not necessary to
		// specify that the status must have been UNHANDLED once

	// Exactly one Party must have this as a Recommendation
	one (receivedRecommendations).this

	// Students must not be recommended to other Students 
	recommendedParty in Student iff this not in Student.receivedRecommendations
	// Offers (and thus Companies) must not be recommended to other Companies
	recommendedParty in Company iff this not in Company.receivedRecommendations
	//				(one of these above is redundant)

	// Companies recommendations must match with the contextOffer's publishing Company
	recommendedParty in Company iff recommendedParty = contextOffer.offeringCompany
}

enum RecommendationStatus { ACCEPTED, REJECTED, UNHANDLED }
